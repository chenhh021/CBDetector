diff --git a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
index 116092c..f3fc768 100644
--- a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
@@ -18,19 +18,30 @@
 
 import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
 
+import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.PrintStream;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.codecs.NormsProducer;
@@ -60,6 +71,7 @@
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LongBitSet;
+import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.SuppressForbidden;
 import org.apache.lucene.util.Version;
@@ -80,6 +92,7 @@
   private Directory dir;
   private Lock writeLock;
   private volatile boolean closed;
+  private NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);
 
   /**
    * Returned from {@link #checkIndex()} detailing the health and status of the index.
@@ -181,6 +194,9 @@
       /** True if we were able to open a CodecReader on this segment. */
       public boolean openReaderPassed;
 
+      /** doc count in this segment */
+      public int toLoseDocCount;
+
       /**
        * Map that includes certain debugging details that IndexWriter records into each segment it
        * creates
@@ -216,6 +232,12 @@
 
       /** Status of vectors */
       public VectorValuesStatus vectorValuesStatus;
+
+      /** Status of soft deletes */
+      public SoftDeletsStatus softDeletesStatus;
+
+      /** Exception thrown during segment test (null on success) */
+      public Throwable error;
     }
 
     /** Status from testing livedocs */
@@ -226,7 +248,7 @@
       public int numDeleted;
 
       /** Exception thrown during term index test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing field infos. */
@@ -237,7 +259,7 @@
       public long totFields = 0L;
 
       /** Exception thrown during term index test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing field norms. */
@@ -248,7 +270,7 @@
       public long totFields = 0L;
 
       /** Exception thrown during term index test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing term index. */
@@ -269,7 +291,7 @@
       public long totPos = 0L;
 
       /** Exception thrown during term index test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
 
       /**
        * Holds details of block allocations in the block tree terms dictionary (this is only set if
@@ -290,7 +312,7 @@
       public long totFields = 0;
 
       /** Exception thrown during stored fields test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing stored fields. */
@@ -305,7 +327,7 @@
       public long totVectors = 0;
 
       /** Exception thrown during term vector test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing DocValues */
@@ -332,7 +354,7 @@
       public long totalSortedSetFields;
 
       /** Exception thrown during doc values test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing PointValues */
@@ -347,7 +369,7 @@
       public int totalValueFields;
 
       /** Exception thrown during point values test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing VectorValues */
@@ -362,7 +384,7 @@
       public int totalKnnVectorFields;
 
       /** Exception thrown during vector values test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
     }
 
     /** Status from testing index sort */
@@ -370,7 +392,15 @@
       IndexSortStatus() {}
 
       /** Exception thrown during term index test (null on success) */
-      public Throwable error = null;
+      public Throwable error;
+    }
+
+    /** Status from testing soft deletes */
+    public static final class SoftDeletsStatus {
+      SoftDeletsStatus() {}
+
+      /** Exception thrown during soft deletes test (null on success) */
+      public Throwable error;
     }
   }
 
@@ -450,6 +480,18 @@
 
   private boolean checksumsOnly;
 
+  /** Set threadCount used for parallelizing index integrity checking. */
+  public void setThreadCount(int tc) {
+    if (tc <= 0) {
+      throw new IllegalArgumentException(
+          "setThreadCount requires a number larger than 0, but got: " + tc);
+    }
+    threadCount = tc;
+  }
+
+  // capped threadCount at 4 for default
+  private int threadCount = Math.min(Runtime.getRuntime().availableProcessors(), 4);
+
   /**
    * Set infoStream where messages should go. If null, no messages are printed. If verbose is true
    * then more details are printed.
@@ -465,7 +507,9 @@
   }
 
   private static void msg(PrintStream out, String msg) {
-    if (out != null) out.println(msg);
+    if (out != null) {
+      out.println(msg);
+    }
   }
 
   /**
@@ -488,9 +532,47 @@
    *     quite a long time to run.
    */
   public Status checkIndex(List<String> onlySegments) throws IOException {
+    ExecutorService executorService = null;
+
+    // if threadCount == 1, then no executor is created and use the main thread to do index checking
+    // sequentially
+    if (threadCount > 1) {
+      executorService =
+          Executors.newFixedThreadPool(threadCount, new NamedThreadFactory("async-check-index"));
+    }
+
+    msg(infoStream, "Checking index with threadCount: " + threadCount);
+    try {
+      return checkIndex(onlySegments, executorService);
+    } finally {
+      if (executorService != null) {
+        executorService.shutdown();
+        try {
+          executorService.awaitTermination(5, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {
+          msg(
+              infoStream,
+              "ERROR: Interrupted exception occurred when shutting down executor service");
+          if (infoStream != null) e.printStackTrace(infoStream);
+        } finally {
+          executorService.shutdownNow();
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns a {@link Status} instance detailing the state of the index.
+   *
+   * <p>This method allows caller to pass in customized ExecutorService to speed up the check.
+   *
+   * <p><b>WARNING</b>: make sure you only call this when the index is not opened by any writer.
+   */
+  public Status checkIndex(List<String> onlySegments, ExecutorService executorService)
+      throws IOException {
     ensureOpen();
     long startNS = System.nanoTime();
-    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);
+
     SegmentInfos sis = null;
     Status result = new Status();
     result.dir = dir;
@@ -526,7 +608,7 @@
       infoStream.println(
           String.format(
               Locale.ROOT,
-              "%.2f%% total deletions; %d documents; %d deleteions",
+              "%.2f%% total deletions; %d documents; %d deletions",
               100. * delCount / maxDoc,
               maxDoc,
               delCount));
@@ -605,209 +687,115 @@
     result.newSegments.clear();
     result.maxSegmentName = -1;
 
-    for (int i = 0; i < numSegments; i++) {
-      final SegmentCommitInfo info = sis.info(i);
-      long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);
-      if (segmentName > result.maxSegmentName) {
-        result.maxSegmentName = segmentName;
-      }
-      if (onlySegments != null && !onlySegments.contains(info.info.name)) {
-        continue;
-      }
-      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();
-      result.segmentInfos.add(segInfoStat);
-      msg(
-          infoStream,
-          "  "
-              + (1 + i)
-              + " of "
-              + numSegments
-              + ": name="
-              + info.info.name
-              + " maxDoc="
-              + info.info.maxDoc());
-      segInfoStat.name = info.info.name;
-      segInfoStat.maxDoc = info.info.maxDoc();
-
-      final Version version = info.info.getVersion();
-      if (info.info.maxDoc() <= 0) {
-        throw new RuntimeException("illegal number of documents: maxDoc=" + info.info.maxDoc());
-      }
-
-      int toLoseDocCount = info.info.maxDoc();
-
-      SegmentReader reader = null;
-
-      try {
-        msg(infoStream, "    version=" + (version == null ? "3.0" : version));
-        msg(infoStream, "    id=" + StringHelper.idToString(info.info.getId()));
-        final Codec codec = info.info.getCodec();
-        msg(infoStream, "    codec=" + codec);
-        segInfoStat.codec = codec;
-        msg(infoStream, "    compound=" + info.info.getUseCompoundFile());
-        segInfoStat.compound = info.info.getUseCompoundFile();
-        msg(infoStream, "    numFiles=" + info.files().size());
-        Sort indexSort = info.info.getIndexSort();
-        if (indexSort != null) {
-          msg(infoStream, "    sort=" + indexSort);
-        }
-        segInfoStat.numFiles = info.files().size();
-        segInfoStat.sizeMB = info.sizeInBytes() / (1024. * 1024.);
-        msg(infoStream, "    size (MB)=" + nf.format(segInfoStat.sizeMB));
-        Map<String, String> diagnostics = info.info.getDiagnostics();
-        segInfoStat.diagnostics = diagnostics;
-        if (diagnostics.size() > 0) {
-          msg(infoStream, "    diagnostics = " + diagnostics);
+    // checks segments sequentially
+    if (executorService == null) {
+      for (int i = 0; i < numSegments; i++) {
+        final SegmentCommitInfo info = sis.info(i);
+        updateMaxSegmentName(result, info);
+        if (onlySegments != null && !onlySegments.contains(info.info.name)) {
+          continue;
         }
 
-        if (!info.hasDeletions()) {
-          msg(infoStream, "    no deletions");
-          segInfoStat.hasDeletions = false;
-        } else {
-          msg(infoStream, "    has deletions [delGen=" + info.getDelGen() + "]");
-          segInfoStat.hasDeletions = true;
-          segInfoStat.deletionsGen = info.getDelGen();
-        }
-
-        long startOpenReaderNS = System.nanoTime();
-        if (infoStream != null) infoStream.print("    test: open reader.........");
-        reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);
         msg(
             infoStream,
-            String.format(
-                Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime() - startOpenReaderNS)));
+            (1 + i)
+                + " of "
+                + numSegments
+                + ": name="
+                + info.info.name
+                + " maxDoc="
+                + info.info.maxDoc());
+        Status.SegmentInfoStatus segmentInfoStatus = testSegment(sis, info, infoStream);
 
-        segInfoStat.openReaderPassed = true;
+        processSegmentInfoStatusResult(result, info, segmentInfoStatus);
+      }
+    } else {
+      ByteArrayOutputStream[] outputs = new ByteArrayOutputStream[numSegments];
+      @SuppressWarnings({"unchecked", "rawtypes"})
+      CompletableFuture<Status.SegmentInfoStatus>[] futures = new CompletableFuture[numSegments];
 
-        long startIntegrityNS = System.nanoTime();
-        if (infoStream != null) infoStream.print("    test: check integrity.....");
-        reader.checkIntegrity();
-        msg(
-            infoStream,
-            String.format(
-                Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime() - startIntegrityNS)));
-
-        if (reader.maxDoc() != info.info.maxDoc()) {
-          throw new RuntimeException(
-              "SegmentReader.maxDoc() "
-                  + reader.maxDoc()
-                  + " != SegmentInfo.maxDoc "
-                  + info.info.maxDoc());
-        }
-
-        final int numDocs = reader.numDocs();
-        toLoseDocCount = numDocs;
-
-        if (reader.hasDeletions()) {
-          if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {
-            throw new RuntimeException(
-                "delete count mismatch: info="
-                    + (info.info.maxDoc() - info.getDelCount())
-                    + " vs reader="
-                    + reader.numDocs());
-          }
-          if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {
-            throw new RuntimeException(
-                "too many deleted docs: maxDoc()="
-                    + reader.maxDoc()
-                    + " vs del count="
-                    + (info.info.maxDoc() - reader.numDocs()));
-          }
-          if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {
-            throw new RuntimeException(
-                "delete count mismatch: info="
-                    + info.getDelCount()
-                    + " vs reader="
-                    + (info.info.maxDoc() - reader.numDocs()));
-          }
-        } else {
-          if (info.getDelCount() != 0) {
-            throw new RuntimeException(
-                "delete count mismatch: info="
-                    + info.getDelCount()
-                    + " vs reader="
-                    + (info.info.maxDoc() - reader.numDocs()));
-          }
-        }
-
-        if (checksumsOnly == false) {
-          // Test Livedocs
-          segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);
-
-          // Test Fieldinfos
-          segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);
-
-          // Test Field Norms
-          segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);
-
-          // Test the Term Index
-          segInfoStat.termIndexStatus =
-              testPostings(reader, infoStream, verbose, doSlowChecks, failFast);
-
-          // Test Stored Fields
-          segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);
-
-          // Test Term Vectors
-          segInfoStat.termVectorStatus =
-              testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);
-
-          // Test Docvalues
-          segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);
-
-          // Test PointValues
-          segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);
-
-          // Test VectorValues
-          segInfoStat.vectorValuesStatus = testVectors(reader, infoStream, failFast);
-
-          // Test index sort
-          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);
-
-          // Rethrow the first exception we encountered
-          //  This will cause stats for failed segments to be incremented properly
-          if (segInfoStat.liveDocStatus.error != null) {
-            throw new RuntimeException("Live docs test failed");
-          } else if (segInfoStat.fieldInfoStatus.error != null) {
-            throw new RuntimeException("Field Info test failed");
-          } else if (segInfoStat.fieldNormStatus.error != null) {
-            throw new RuntimeException("Field Norm test failed");
-          } else if (segInfoStat.termIndexStatus.error != null) {
-            throw new RuntimeException("Term Index test failed");
-          } else if (segInfoStat.storedFieldStatus.error != null) {
-            throw new RuntimeException("Stored Field test failed");
-          } else if (segInfoStat.termVectorStatus.error != null) {
-            throw new RuntimeException("Term Vector test failed");
-          } else if (segInfoStat.docValuesStatus.error != null) {
-            throw new RuntimeException("DocValues test failed");
-          } else if (segInfoStat.pointsStatus.error != null) {
-            throw new RuntimeException("Points test failed");
-          }
-        }
-        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();
-        if (softDeletesField != null) {
-          checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);
-        }
-        msg(infoStream, "");
-
-      } catch (Throwable t) {
-        if (failFast) {
-          throw IOUtils.rethrowAlways(t);
-        }
-        msg(infoStream, "FAILED");
-        String comment;
-        comment = "exorciseIndex() would remove reference to this segment";
-        msg(infoStream, "    WARNING: " + comment + "; full exception:");
-        if (infoStream != null) t.printStackTrace(infoStream);
-        msg(infoStream, "");
-        result.totLoseDocCount += toLoseDocCount;
-        result.numBadSegments++;
-        continue;
-      } finally {
-        if (reader != null) reader.close();
+      // checks segments concurrently
+      List<SegmentCommitInfo> segmentCommitInfos = new ArrayList<>();
+      for (SegmentCommitInfo sci : sis) {
+        segmentCommitInfos.add(sci);
       }
 
-      // Keeper
-      result.newSegments.add(info.clone());
+      // sort segmentCommitInfos by segment size, as smaller segment tends to finish faster, and
+      // hence its output can be printed out faster
+      Collections.sort(
+          segmentCommitInfos,
+          (info1, info2) -> {
+            try {
+              return Long.compare(info1.sizeInBytes(), info2.sizeInBytes());
+            } catch (IOException e) {
+              msg(
+                  infoStream,
+                  "ERROR: IOException occurred when comparing SegmentCommitInfo file sizes");
+              if (infoStream != null) e.printStackTrace(infoStream);
+              return 0;
+            }
+          });
+
+      // start larger segments earlier
+      for (int i = numSegments - 1; i >= 0; i--) {
+        final SegmentCommitInfo info = segmentCommitInfos.get(i);
+        updateMaxSegmentName(result, info);
+        if (onlySegments != null && !onlySegments.contains(info.info.name)) {
+          continue;
+        }
+
+        SegmentInfos finalSis = sis;
+
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        PrintStream stream = new PrintStream(output, true, IOUtils.UTF_8);
+        msg(
+            stream,
+            (1 + i)
+                + " of "
+                + numSegments
+                + ": name="
+                + info.info.name
+                + " maxDoc="
+                + info.info.maxDoc());
+
+        outputs[i] = output;
+        futures[i] =
+            runAsyncSegmentCheck(() -> testSegment(finalSis, info, stream), executorService);
+      }
+
+      for (int i = 0; i < numSegments; i++) {
+        SegmentCommitInfo info = segmentCommitInfos.get(i);
+        if (onlySegments != null && !onlySegments.contains(info.info.name)) {
+          continue;
+        }
+
+        ByteArrayOutputStream output = outputs[i];
+
+        // print segment results in order
+        Status.SegmentInfoStatus segmentInfoStatus = null;
+        try {
+          segmentInfoStatus = futures[i].get();
+        } catch (InterruptedException e) {
+          // the segment test output should come before interrupted exception message that follows,
+          // hence it's not emitted from finally clause
+          infoStream.println(output.toString(StandardCharsets.UTF_8));
+          msg(
+              infoStream,
+              "ERROR: Interrupted exception occurred when getting segment check result for segment "
+                  + info.info.name);
+          if (infoStream != null) e.printStackTrace(infoStream);
+        } catch (ExecutionException e) {
+          infoStream.println(output.toString(StandardCharsets.UTF_8));
+
+          assert failFast;
+          throw new CheckIndexException(
+              "Segment " + info.info.name + " check failed.", e.getCause());
+        }
+
+        infoStream.print(output.toString(StandardCharsets.UTF_8));
+
+        processSegmentInfoStatusResult(result, info, segmentInfoStatus);
+      }
     }
 
     if (0 == result.numBadSegments) {
@@ -843,6 +831,255 @@
     return result;
   }
 
+  private void updateMaxSegmentName(Status result, SegmentCommitInfo info) {
+    long segmentName = Long.parseLong(info.info.name.substring(1), Character.MAX_RADIX);
+    if (segmentName > result.maxSegmentName) {
+      result.maxSegmentName = segmentName;
+    }
+  }
+
+  private void processSegmentInfoStatusResult(
+      Status result, SegmentCommitInfo info, Status.SegmentInfoStatus segmentInfoStatus) {
+    result.segmentInfos.add(segmentInfoStatus);
+    if (segmentInfoStatus.error != null) {
+      result.totLoseDocCount += segmentInfoStatus.toLoseDocCount;
+      result.numBadSegments++;
+    } else {
+      // Keeper
+      result.newSegments.add(info.clone());
+    }
+  }
+
+  private <R> CompletableFuture<R> runAsyncSegmentCheck(
+      Callable<R> asyncCallable, ExecutorService executorService) {
+    return CompletableFuture.supplyAsync(callableToSupplier(asyncCallable), executorService);
+  }
+
+  private <T> Supplier<T> callableToSupplier(Callable<T> callable) {
+    return () -> {
+      try {
+        return callable.call();
+      } catch (RuntimeException | Error e) {
+        throw e;
+      } catch (Throwable e) {
+        throw new CompletionException(e);
+      }
+    };
+  }
+
+  private Status.SegmentInfoStatus testSegment(
+      SegmentInfos sis, SegmentCommitInfo info, PrintStream infoStream) throws IOException {
+    Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();
+    segInfoStat.name = info.info.name;
+    segInfoStat.maxDoc = info.info.maxDoc();
+
+    final Version version = info.info.getVersion();
+    if (info.info.maxDoc() <= 0) {
+      throw new CheckIndexException(" illegal number of documents: maxDoc=" + info.info.maxDoc());
+    }
+
+    int toLoseDocCount = info.info.maxDoc();
+
+    SegmentReader reader = null;
+
+    try {
+      msg(infoStream, "    version=" + (version == null ? "3.0" : version));
+      msg(infoStream, "    id=" + StringHelper.idToString(info.info.getId()));
+      final Codec codec = info.info.getCodec();
+      msg(infoStream, "    codec=" + codec);
+      segInfoStat.codec = codec;
+      msg(infoStream, "    compound=" + info.info.getUseCompoundFile());
+      segInfoStat.compound = info.info.getUseCompoundFile();
+      msg(infoStream, "    numFiles=" + info.files().size());
+      Sort indexSort = info.info.getIndexSort();
+      if (indexSort != null) {
+        msg(infoStream, "    sort=" + indexSort);
+      }
+      segInfoStat.numFiles = info.files().size();
+      segInfoStat.sizeMB = info.sizeInBytes() / (1024. * 1024.);
+      // nf#format is not thread-safe, and would generate random non valid results in concurrent
+      // setting
+      synchronized (nf) {
+        msg(infoStream, "    size (MB)=" + nf.format(segInfoStat.sizeMB));
+      }
+      Map<String, String> diagnostics = info.info.getDiagnostics();
+      segInfoStat.diagnostics = diagnostics;
+      if (diagnostics.size() > 0) {
+        msg(infoStream, "    diagnostics = " + diagnostics);
+      }
+
+      if (!info.hasDeletions()) {
+        msg(infoStream, "    no deletions");
+        segInfoStat.hasDeletions = false;
+      } else {
+        msg(infoStream, "    has deletions [delGen=" + info.getDelGen() + "]");
+        segInfoStat.hasDeletions = true;
+        segInfoStat.deletionsGen = info.getDelGen();
+      }
+
+      long startOpenReaderNS = System.nanoTime();
+      if (infoStream != null) infoStream.print("    test: open reader.........");
+      reader = new SegmentReader(info, sis.getIndexCreatedVersionMajor(), IOContext.DEFAULT);
+      msg(
+          infoStream,
+          String.format(
+              Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime() - startOpenReaderNS)));
+
+      segInfoStat.openReaderPassed = true;
+
+      long startIntegrityNS = System.nanoTime();
+      if (infoStream != null) infoStream.print("    test: check integrity.....");
+      reader.checkIntegrity();
+      msg(
+          infoStream,
+          String.format(
+              Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime() - startIntegrityNS)));
+
+      if (reader.maxDoc() != info.info.maxDoc()) {
+        throw new CheckIndexException(
+            "SegmentReader.maxDoc() "
+                + reader.maxDoc()
+                + " != SegmentInfo.maxDoc "
+                + info.info.maxDoc());
+      }
+
+      final int numDocs = reader.numDocs();
+      toLoseDocCount = numDocs;
+
+      if (reader.hasDeletions()) {
+        if (reader.numDocs() != info.info.maxDoc() - info.getDelCount()) {
+          throw new CheckIndexException(
+              "delete count mismatch: info="
+                  + (info.info.maxDoc() - info.getDelCount())
+                  + " vs reader="
+                  + reader.numDocs());
+        }
+        if ((info.info.maxDoc() - reader.numDocs()) > reader.maxDoc()) {
+          throw new CheckIndexException(
+              "too many deleted docs: maxDoc()="
+                  + reader.maxDoc()
+                  + " vs del count="
+                  + (info.info.maxDoc() - reader.numDocs()));
+        }
+        if (info.info.maxDoc() - reader.numDocs() != info.getDelCount()) {
+          throw new CheckIndexException(
+              "delete count mismatch: info="
+                  + info.getDelCount()
+                  + " vs reader="
+                  + (info.info.maxDoc() - reader.numDocs()));
+        }
+      } else {
+        if (info.getDelCount() != 0) {
+          throw new CheckIndexException(
+              "delete count mismatch: info="
+                  + info.getDelCount()
+                  + " vs reader="
+                  + (info.info.maxDoc() - reader.numDocs()));
+        }
+      }
+
+      if (checksumsOnly == false) {
+        // Test Livedocs
+        segInfoStat.liveDocStatus = testLiveDocs(reader, infoStream, failFast);
+
+        // Test Fieldinfos
+        segInfoStat.fieldInfoStatus = testFieldInfos(reader, infoStream, failFast);
+
+        // Test Field Norms
+        segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);
+
+        // Test the Term Index
+        segInfoStat.termIndexStatus =
+            testPostings(reader, infoStream, verbose, doSlowChecks, failFast);
+
+        // Test Stored Fields
+        segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);
+
+        // Test Term Vectors
+        segInfoStat.termVectorStatus =
+            testTermVectors(reader, infoStream, verbose, doSlowChecks, failFast);
+
+        // Test Docvalues
+        segInfoStat.docValuesStatus = testDocValues(reader, infoStream, failFast);
+
+        // Test PointValues
+        segInfoStat.pointsStatus = testPoints(reader, infoStream, failFast);
+
+        // Test VectorValues
+        segInfoStat.vectorValuesStatus = testVectors(reader, infoStream, failFast);
+
+        // Test Index Sort
+        if (indexSort != null) {
+          segInfoStat.indexSortStatus = testSort(reader, indexSort, infoStream, failFast);
+        }
+
+        // Test Soft Deletes
+        final String softDeletesField = reader.getFieldInfos().getSoftDeletesField();
+        if (softDeletesField != null) {
+          segInfoStat.softDeletesStatus =
+              checkSoftDeletes(softDeletesField, info, reader, infoStream, failFast);
+        }
+
+        // Rethrow the first exception we encountered
+        //  This will cause stats for failed segments to be incremented properly
+        // We won't be able to (easily) stop check running in another thread, so we may as well
+        // wait for all of them to complete before we proceed, and that we don't throw
+        // CheckIndexException
+        // below while the segment part check may still print out messages
+        if (segInfoStat.liveDocStatus.error != null) {
+          throw new CheckIndexException("Live docs test failed", segInfoStat.liveDocStatus.error);
+        } else if (segInfoStat.fieldInfoStatus.error != null) {
+          throw new CheckIndexException(
+              "Field Info test failed", segInfoStat.fieldInfoStatus.error);
+        } else if (segInfoStat.fieldNormStatus.error != null) {
+          throw new CheckIndexException(
+              "Field Norm test failed", segInfoStat.fieldNormStatus.error);
+        } else if (segInfoStat.termIndexStatus.error != null) {
+          throw new CheckIndexException(
+              "Term Index test failed", segInfoStat.termIndexStatus.error);
+        } else if (segInfoStat.storedFieldStatus.error != null) {
+          throw new CheckIndexException(
+              "Stored Field test failed", segInfoStat.storedFieldStatus.error);
+        } else if (segInfoStat.termVectorStatus.error != null) {
+          throw new CheckIndexException(
+              "Term Vector test failed", segInfoStat.termVectorStatus.error);
+        } else if (segInfoStat.docValuesStatus.error != null) {
+          throw new CheckIndexException("DocValues test failed", segInfoStat.docValuesStatus.error);
+        } else if (segInfoStat.pointsStatus.error != null) {
+          throw new CheckIndexException("Points test failed", segInfoStat.pointsStatus.error);
+        } else if (segInfoStat.vectorValuesStatus.error != null) {
+          throw new CheckIndexException(
+              "Vectors test failed", segInfoStat.vectorValuesStatus.error);
+        } else if (segInfoStat.indexSortStatus != null
+            && segInfoStat.indexSortStatus.error != null) {
+          throw new CheckIndexException(
+              "Index Sort test failed", segInfoStat.indexSortStatus.error);
+        } else if (segInfoStat.softDeletesStatus != null
+            && segInfoStat.softDeletesStatus.error != null) {
+          throw new CheckIndexException(
+              "Soft Deletes test failed", segInfoStat.softDeletesStatus.error);
+        }
+      }
+
+      msg(infoStream, "");
+    } catch (Throwable t) {
+      if (failFast) {
+        throw IOUtils.rethrowAlways(t);
+      }
+      segInfoStat.error = t;
+      segInfoStat.toLoseDocCount = toLoseDocCount;
+      msg(infoStream, "FAILED");
+      String comment;
+      comment = "exorciseIndex() would remove reference to this segment";
+      msg(infoStream, "    WARNING: " + comment + "; full exception:");
+      if (infoStream != null) t.printStackTrace(infoStream);
+      msg(infoStream, "");
+    } finally {
+      if (reader != null) reader.close();
+    }
+    return segInfoStat;
+  }
+
   /**
    * Tests index sort order.
    *
@@ -893,7 +1130,7 @@
           }
 
           if (cmp > 0) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "segment has indexSort="
                     + sort
                     + " but docID="
@@ -936,7 +1173,7 @@
       if (reader.hasDeletions()) {
         Bits liveDocs = reader.getLiveDocs();
         if (liveDocs == null) {
-          throw new RuntimeException("segment should have deletions, but liveDocs is null");
+          throw new CheckIndexException("segment should have deletions, but liveDocs is null");
         } else {
           int numLive = 0;
           for (int j = 0; j < liveDocs.length(); j++) {
@@ -945,7 +1182,7 @@
             }
           }
           if (numLive != numDocs) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "liveDocs count mismatch: info=" + numDocs + ", vs bits=" + numLive);
           }
         }
@@ -964,7 +1201,7 @@
           // it's ok for it to be non-null here, as long as none are set right?
           for (int j = 0; j < liveDocs.length(); j++) {
             if (!liveDocs.get(j)) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "liveDocs mismatch: info says no deletions but doc " + j + " is deleted.");
             }
           }
@@ -1111,7 +1348,7 @@
 
       // MultiFieldsEnum relies upon this order...
       if (lastField != null && field.compareTo(lastField) <= 0) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "fields out of order: lastField=" + lastField + " field=" + field);
       }
       lastField = field;
@@ -1120,11 +1357,11 @@
       // TODO: add a separate test to check this for different reader impls
       FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
       if (fieldInfo == null) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "fieldsEnum inconsistent with fieldInfos, no fieldInfos for: " + field);
       }
       if (fieldInfo.getIndexOptions() == IndexOptions.NONE) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "fieldsEnum inconsistent with fieldInfos, isIndexed == false for: " + field);
       }
 
@@ -1140,7 +1377,7 @@
       }
 
       if (terms.getDocCount() > maxDoc) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "docCount > maxDoc for field: "
                 + field
                 + ", docCount="
@@ -1174,13 +1411,13 @@
           assert bb.isValid();
           maxTerm = BytesRef.deepCopyOf(bb);
           if (minTerm == null) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field \"" + field + "\" has null minTerm but non-null maxTerm");
           }
         } else {
           maxTerm = null;
           if (minTerm != null) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field \"" + field + "\" has non-null minTerm but null maxTerm");
           }
         }
@@ -1191,7 +1428,7 @@
           (isVectors || fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0);
 
       if (hasFreqs != expectedHasFreqs) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "field \""
                 + field
                 + "\" should have hasFreqs="
@@ -1204,7 +1441,7 @@
         final boolean expectedHasPositions =
             fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
         if (hasPositions != expectedHasPositions) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "field \""
                   + field
                   + "\" should have hasPositions="
@@ -1215,7 +1452,7 @@
 
         final boolean expectedHasPayloads = fieldInfo.hasPayloads();
         if (hasPayloads != expectedHasPayloads) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "field \""
                   + field
                   + "\" should have hasPayloads="
@@ -1230,7 +1467,7 @@
                     .compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)
                 >= 0;
         if (hasOffsets != expectedHasOffsets) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "field \""
                   + field
                   + "\" should have hasOffsets="
@@ -1268,7 +1505,7 @@
           lastTerm.copyBytes(term);
         } else {
           if (lastTerm.get().compareTo(term) >= 0) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "terms out of order: lastTerm=" + lastTerm.get() + " term=" + term);
           }
           lastTerm.copyBytes(term);
@@ -1278,24 +1515,24 @@
           if (minTerm == null) {
             // We checked this above:
             assert maxTerm == null;
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field=\"" + field + "\": invalid term: term=" + term + ", minTerm=" + minTerm);
           }
 
           if (term.compareTo(minTerm) < 0) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field=\"" + field + "\": invalid term: term=" + term + ", minTerm=" + minTerm);
           }
 
           if (term.compareTo(maxTerm) > 0) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field=\"" + field + "\": invalid term: term=" + term + ", maxTerm=" + maxTerm);
           }
         }
 
         final int docFreq = termsEnum.docFreq();
         if (docFreq <= 0) {
-          throw new RuntimeException("docfreq: " + docFreq + " is out of bounds");
+          throw new CheckIndexException("docfreq: " + docFreq + " is out of bounds");
         }
         sumDocFreq += docFreq;
 
@@ -1303,7 +1540,7 @@
 
         if (hasFreqs == false) {
           if (termsEnum.totalTermFreq() != termsEnum.docFreq()) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "field \""
                     + field
                     + "\" hasFreqs is false, but TermsEnum.totalTermFreq()="
@@ -1327,7 +1564,7 @@
           if (hasOrd) {
             final long ordExpected = status.delTermCount + status.termCount - termCountStart;
             if (ord != ordExpected) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "ord mismatch: TermsEnum has ord=" + ord + " vs actual=" + ordExpected);
             }
           }
@@ -1345,7 +1582,7 @@
           visitedDocs.set(doc);
           int freq = postings.freq();
           if (freq <= 0) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "term " + term + ": doc " + doc + ": freq " + freq + " is out of bounds");
           }
           if (hasFreqs == false) {
@@ -1353,7 +1590,7 @@
             // consistently "lie" and pretend that freq was
             // 1:
             if (postings.freq() != 1) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "term "
                       + term
                       + ": doc "
@@ -1375,10 +1612,11 @@
           docCount++;
 
           if (doc <= lastDoc) {
-            throw new RuntimeException("term " + term + ": doc " + doc + " <= lastDoc " + lastDoc);
+            throw new CheckIndexException(
+                "term " + term + ": doc " + doc + " <= lastDoc " + lastDoc);
           }
           if (doc >= maxDoc) {
-            throw new RuntimeException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);
+            throw new CheckIndexException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);
           }
 
           lastDoc = doc;
@@ -1390,11 +1628,11 @@
               final int pos = postings.nextPosition();
 
               if (pos < 0) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term " + term + ": doc " + doc + ": pos " + pos + " is out of bounds");
               }
               if (pos > IndexWriter.MAX_POSITION) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term "
                         + term
                         + ": doc "
@@ -1405,7 +1643,7 @@
                         + IndexWriter.MAX_POSITION);
               }
               if (pos < lastPos) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term " + term + ": doc " + doc + ": pos " + pos + " < lastPos " + lastPos);
               }
               lastPos = pos;
@@ -1414,7 +1652,7 @@
                 assert payload.isValid();
               }
               if (payload != null && payload.length < 1) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term "
                         + term
                         + ": doc "
@@ -1428,7 +1666,7 @@
                 int startOffset = postings.startOffset();
                 int endOffset = postings.endOffset();
                 if (startOffset < 0) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "term "
                           + term
                           + ": doc "
@@ -1440,7 +1678,7 @@
                           + " is out of bounds");
                 }
                 if (startOffset < lastOffset) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "term "
                           + term
                           + ": doc "
@@ -1454,7 +1692,7 @@
                           + "; consider using the FixBrokenOffsets tool in Lucene's backward-codecs module to correct your index");
                 }
                 if (endOffset < 0) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "term "
                           + term
                           + ": doc "
@@ -1466,7 +1704,7 @@
                           + " is out of bounds");
                 }
                 if (endOffset < startOffset) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "term "
                           + term
                           + ": doc "
@@ -1493,19 +1731,19 @@
         final long totalTermFreq2 = termsEnum.totalTermFreq();
 
         if (docCount != docFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "term " + term + " docFreq=" + docFreq + " != tot docs w/o deletions " + docCount);
         }
         if (docFreq > terms.getDocCount()) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "term " + term + " docFreq=" + docFreq + " > docCount=" + terms.getDocCount());
         }
         if (totalTermFreq2 <= 0) {
-          throw new RuntimeException("totalTermFreq: " + totalTermFreq2 + " is out of bounds");
+          throw new CheckIndexException("totalTermFreq: " + totalTermFreq2 + " is out of bounds");
         }
         sumTotalTermFreq += totalTermFreq;
         if (totalTermFreq != totalTermFreq2) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "term "
                   + term
                   + " totalTermFreq="
@@ -1514,11 +1752,11 @@
                   + totalTermFreq);
         }
         if (totalTermFreq2 < docFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "totalTermFreq: " + totalTermFreq2 + " is out of bounds, docFreq=" + docFreq);
         }
         if (hasFreqs == false && totalTermFreq != docFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "term " + term + " totalTermFreq=" + totalTermFreq + " !=  docFreq=" + docFreq);
         }
 
@@ -1532,12 +1770,12 @@
               break;
             } else {
               if (docID < skipDocID) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term " + term + ": advance(docID=" + skipDocID + ") returned docID=" + docID);
               }
               final int freq = postings.freq();
               if (freq <= 0) {
-                throw new RuntimeException("termFreq " + freq + " is out of bounds");
+                throw new CheckIndexException("termFreq " + freq + " is out of bounds");
               }
               int lastPosition = -1;
               int lastOffset = 0;
@@ -1545,10 +1783,10 @@
                 final int pos = postings.nextPosition();
 
                 if (pos < 0) {
-                  throw new RuntimeException("position " + pos + " is out of bounds");
+                  throw new CheckIndexException("position " + pos + " is out of bounds");
                 }
                 if (pos < lastPosition) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "position " + pos + " is < lastPosition " + lastPosition);
                 }
                 lastPosition = pos;
@@ -1561,7 +1799,7 @@
                   // enforced by IndexWriter
                   if (!isVectors) {
                     if (startOffset < 0) {
-                      throw new RuntimeException(
+                      throw new CheckIndexException(
                           "term "
                               + term
                               + ": doc "
@@ -1573,7 +1811,7 @@
                               + " is out of bounds");
                     }
                     if (startOffset < lastOffset) {
-                      throw new RuntimeException(
+                      throw new CheckIndexException(
                           "term "
                               + term
                               + ": doc "
@@ -1586,7 +1824,7 @@
                               + lastOffset);
                     }
                     if (endOffset < 0) {
-                      throw new RuntimeException(
+                      throw new CheckIndexException(
                           "term "
                               + term
                               + ": doc "
@@ -1598,7 +1836,7 @@
                               + " is out of bounds");
                     }
                     if (endOffset < startOffset) {
-                      throw new RuntimeException(
+                      throw new CheckIndexException(
                           "term "
                               + term
                               + ": doc "
@@ -1620,7 +1858,7 @@
                 break;
               }
               if (nextDocID <= docID) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term "
                         + term
                         + ": advance(docID="
@@ -1646,7 +1884,7 @@
               break;
             } else {
               if (docID < skipDocID) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term " + term + ": advance(docID=" + skipDocID + ") returned docID=" + docID);
               }
               final int nextDocID = postings.nextDoc();
@@ -1654,7 +1892,7 @@
                 break;
               }
               if (nextDocID <= docID) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "term "
                         + term
                         + ": advance(docID="
@@ -1687,14 +1925,14 @@
             postings = termsEnum.postings(postings, PostingsEnum.FREQS);
             for (int doc = impactsEnum.nextDoc(); ; doc = impactsEnum.nextDoc()) {
               if (postings.nextDoc() != doc) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "Wrong next doc: " + doc + ", expected " + postings.docID());
               }
               if (doc == DocIdSetIterator.NO_MORE_DOCS) {
                 break;
               }
               if (postings.freq() != impactsEnum.freq()) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "Wrong freq, expected " + postings.freq() + ", but got " + impactsEnum.freq());
               }
               if (doc > max) {
@@ -1706,7 +1944,7 @@
                 maxFreq = impacts0.get(impacts0.size() - 1).freq;
               }
               if (impactsEnum.freq() > maxFreq) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "freq "
                         + impactsEnum.freq()
                         + " is greater than the max freq according to impacts "
@@ -1763,7 +2001,7 @@
             }
 
             if (postings.advance(target) != doc) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Impacts do not advance to the same document as postings for target "
                       + target
                       + ", postings: "
@@ -1775,7 +2013,7 @@
               break;
             }
             if (postings.freq() != impactsEnum.freq()) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Wrong freq, expected " + postings.freq() + ", but got " + impactsEnum.freq());
             }
 
@@ -1799,7 +2037,7 @@
             }
 
             if (impactsEnum.freq() > maxFreq) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Term frequency "
                       + impactsEnum.freq()
                       + " is greater than the max freq according to impacts "
@@ -1810,7 +2048,7 @@
       }
 
       if (minTerm != null && status.termCount + status.delTermCount == 0) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "field=\"" + field + "\": minTerm is non-null yet we saw no terms: " + minTerm);
       }
 
@@ -1835,7 +2073,7 @@
 
         final long actualSumDocFreq = fields.terms(field).getSumDocFreq();
         if (sumDocFreq != actualSumDocFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "sumDocFreq for field "
                   + field
                   + "="
@@ -1846,7 +2084,7 @@
 
         final long actualSumTotalTermFreq = fields.terms(field).getSumTotalTermFreq();
         if (sumTotalTermFreq != actualSumTotalTermFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "sumTotalTermFreq for field "
                   + field
                   + "="
@@ -1856,7 +2094,7 @@
         }
 
         if (hasFreqs == false && sumTotalTermFreq != sumDocFreq) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "sumTotalTermFreq for field "
                   + field
                   + " should be "
@@ -1867,7 +2105,7 @@
 
         final int v = fieldTerms.getDocCount();
         if (visitedDocs.cardinality() != v) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "docCount for field "
                   + field
                   + "="
@@ -1890,13 +2128,13 @@
             }
             final long norm = norms.longValue();
             if (norm != 0 && visitedDocs.get(doc) == false) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Document "
                       + doc
                       + " doesn't have terms according to postings but has a norm value that is not zero: "
                       + Long.toUnsignedString(norm));
             } else if (norm == 0 && visitedDocs.get(doc)) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Document "
                       + doc
                       + " has terms according to postings but its norm value is 0, which may only be used on documents that have no terms");
@@ -1907,10 +2145,10 @@
         // Test seek to last term:
         if (lastTerm != null) {
           if (termsEnum.seekCeil(lastTerm.get()) != TermsEnum.SeekStatus.FOUND) {
-            throw new RuntimeException("seek to last term " + lastTerm.get() + " failed");
+            throw new CheckIndexException("seek to last term " + lastTerm.get() + " failed");
           }
           if (termsEnum.term().equals(lastTerm.get()) == false) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "seek to last term "
                     + lastTerm.get()
                     + " returned FOUND but seeked to the wrong term "
@@ -1924,7 +2162,7 @@
             docFreq++;
           }
           if (docFreq != expectedDocFreq) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "docFreq for last term "
                     + lastTerm.get()
                     + "="
@@ -1941,7 +2179,8 @@
           termCount = fields.terms(field).size();
 
           if (termCount != -1 && termCount != fieldTermCount) {
-            throw new RuntimeException("termCount mismatch " + termCount + " vs " + fieldTermCount);
+            throw new CheckIndexException(
+                "termCount mismatch " + termCount + " vs " + fieldTermCount);
           }
         }
 
@@ -1957,7 +2196,7 @@
               termsEnum.seekExact(ord);
               long actualOrd = termsEnum.ord();
               if (actualOrd != ord) {
-                throw new RuntimeException("seek to ord " + ord + " returned ord " + actualOrd);
+                throw new CheckIndexException("seek to ord " + ord + " returned ord " + actualOrd);
               }
               seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());
             }
@@ -1965,10 +2204,10 @@
             // Seek by term
             for (int i = seekCount - 1; i >= 0; i--) {
               if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {
-                throw new RuntimeException("seek to existing term " + seekTerms[i] + " failed");
+                throw new CheckIndexException("seek to existing term " + seekTerms[i] + " failed");
               }
               if (termsEnum.term().equals(seekTerms[i]) == false) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "seek to existing term "
                         + seekTerms[i]
                         + " returned FOUND but seeked to the wrong term "
@@ -1977,7 +2216,8 @@
 
               postings = termsEnum.postings(postings, PostingsEnum.NONE);
               if (postings == null) {
-                throw new RuntimeException("null DocsEnum from to existing term " + seekTerms[i]);
+                throw new CheckIndexException(
+                    "null DocsEnum from to existing term " + seekTerms[i]);
               }
             }
           }
@@ -1989,10 +2229,10 @@
 
     if (fieldCount != -1) {
       if (fieldCount < 0) {
-        throw new RuntimeException("invalid fieldCount: " + fieldCount);
+        throw new CheckIndexException("invalid fieldCount: " + fieldCount);
       }
       if (fieldCount != computedFieldCount) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "fieldCount mismatch "
                 + fieldCount
                 + " vs recomputed field count "
@@ -2025,12 +2265,12 @@
   static void checkImpacts(Impacts impacts, int lastTarget) {
     final int numLevels = impacts.numLevels();
     if (numLevels < 1) {
-      throw new RuntimeException("The number of levels must be >= 1, got " + numLevels);
+      throw new CheckIndexException("The number of levels must be >= 1, got " + numLevels);
     }
 
     int docIdUpTo0 = impacts.getDocIdUpTo(0);
     if (docIdUpTo0 < lastTarget) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "getDocIdUpTo returned "
               + docIdUpTo0
               + " on level 0, which is less than the target "
@@ -2041,7 +2281,7 @@
       int docIdUpTo = impacts.getDocIdUpTo(level);
       int previousDocIdUpTo = impacts.getDocIdUpTo(level - 1);
       if (docIdUpTo < previousDocIdUpTo) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "Decreasing return for getDocIdUpTo: level "
                 + (level - 1)
                 + " returned "
@@ -2058,21 +2298,21 @@
     for (int level = 0; level < numLevels; ++level) {
       List<Impact> perLevelImpacts = impacts.getImpacts(level);
       if (perLevelImpacts.isEmpty()) {
-        throw new RuntimeException("Got empty list of impacts on level " + level);
+        throw new CheckIndexException("Got empty list of impacts on level " + level);
       }
       Impact first = perLevelImpacts.get(0);
       if (first.freq < 1) {
-        throw new RuntimeException("First impact had a freq <= 0: " + first);
+        throw new CheckIndexException("First impact had a freq <= 0: " + first);
       }
       if (first.norm == 0) {
-        throw new RuntimeException("First impact had a norm == 0: " + first);
+        throw new CheckIndexException("First impact had a norm == 0: " + first);
       }
       // Impacts must be in increasing order of norm AND freq
       Impact previous = first;
       for (int i = 1; i < perLevelImpacts.size(); ++i) {
         Impact impact = perLevelImpacts.get(i);
         if (impact.freq <= previous.freq || Long.compareUnsigned(impact.norm, previous.norm) <= 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "Impacts are not ordered or contain dups, got " + previous + " then " + impact);
         }
       }
@@ -2090,7 +2330,7 @@
             continue;
           }
           if (it.hasNext() == false) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "Found impact "
                     + previous
                     + " on level "
@@ -2131,7 +2371,6 @@
 
     // TODO: we should go and verify term vectors match, if
     // doSlowChecks is on...
-
     Status.TermIndexStatus status;
     final int maxDoc = reader.maxDoc();
 
@@ -2191,7 +2430,7 @@
       if (fieldInfos.hasPointValues()) {
         PointsReader pointsReader = reader.getPointsReader();
         if (pointsReader == null) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "there are fields with points, but reader.getPointsReader() is null");
         }
         for (FieldInfo fieldInfo : fieldInfos) {
@@ -2210,21 +2449,22 @@
                 values.estimatePointCount(
                     new ConstantRelationIntersectVisitor(Relation.CELL_CROSSES_QUERY));
             if (crossCost < size / 2) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "estimatePointCount should return >= size/2 when all cells match");
             }
             final long insideCost =
                 values.estimatePointCount(
                     new ConstantRelationIntersectVisitor(Relation.CELL_INSIDE_QUERY));
             if (insideCost < size) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "estimatePointCount should return >= size when all cells fully match");
             }
             final long outsideCost =
                 values.estimatePointCount(
                     new ConstantRelationIntersectVisitor(Relation.CELL_OUTSIDE_QUERY));
             if (outsideCost != 0) {
-              throw new RuntimeException("estimatePointCount should return 0 when no cells match");
+              throw new CheckIndexException(
+                  "estimatePointCount should return 0 when no cells match");
             }
 
             VerifyPointsVisitor visitor =
@@ -2232,7 +2472,7 @@
             values.intersect(visitor);
 
             if (visitor.getPointCountSeen() != size) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "point values for field \""
                       + fieldInfo.name
                       + "\" claims to have size="
@@ -2242,7 +2482,7 @@
             }
 
             if (visitor.getDocCountSeen() != docCount) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "point values for field \""
                       + fieldInfo.name
                       + "\" claims to have docCount="
@@ -2287,7 +2527,7 @@
   public static Status.VectorValuesStatus testVectors(
       CodecReader reader, PrintStream infoStream, boolean failFast) throws IOException {
     if (infoStream != null) {
-      infoStream.print("    test: vectors..............");
+      infoStream.print("    test: vectors.............");
     }
     long startNS = System.nanoTime();
     FieldInfos fieldInfos = reader.getFieldInfos();
@@ -2299,7 +2539,7 @@
           if (fieldInfo.hasVectorValues()) {
             int dimension = fieldInfo.getVectorDimension();
             if (dimension <= 0) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Field \""
                       + fieldInfo.name
                       + "\" has vector values but dimension is "
@@ -2316,7 +2556,7 @@
             while (values.nextDoc() != NO_MORE_DOCS) {
               int valueLength = values.vectorValue().length;
               if (valueLength != dimension) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "Field \""
                         + fieldInfo.name
                         + "\" has a value whose dimension="
@@ -2327,7 +2567,7 @@
               ++docCount;
             }
             if (docCount != values.size()) {
-              throw new RuntimeException(
+              throw new CheckIndexException(
                   "Field \""
                       + fieldInfo.name
                       + "\" has size="
@@ -2403,7 +2643,7 @@
       lastPackedValue = new byte[packedBytesCount];
 
       if (values.getDocCount() > values.size()) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "point values for field \""
                 + fieldName
                 + "\" claims to have size="
@@ -2413,7 +2653,7 @@
       }
 
       if (values.getDocCount() > maxDoc) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "point values for field \""
                 + fieldName
                 + "\" claims to have docCount="
@@ -2424,14 +2664,14 @@
 
       if (globalMinPackedValue == null) {
         if (values.size() != 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "getMinPackedValue is null points for field \""
                   + fieldName
                   + "\" yet size="
                   + values.size());
         }
       } else if (globalMinPackedValue.length != packedIndexBytesCount) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "getMinPackedValue for field \""
                 + fieldName
                 + "\" return length="
@@ -2441,14 +2681,14 @@
       }
       if (globalMaxPackedValue == null) {
         if (values.size() != 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "getMaxPackedValue is null points for field \""
                   + fieldName
                   + "\" yet size="
                   + values.size());
         }
       } else if (globalMaxPackedValue.length != packedIndexBytesCount) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "getMaxPackedValue for field \""
                 + fieldName
                 + "\" return length="
@@ -2470,7 +2710,7 @@
 
     @Override
     public void visit(int docID) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "codec called IntersectVisitor.visit without a packed value for docID=" + docID);
     }
 
@@ -2494,7 +2734,7 @@
             < 0) {
           // This doc's point, in this dimension, is lower than the minimum value of the last cell
           // checked:
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points value "
                   + Arrays.toString(packedValue)
                   + " for field=\""
@@ -2519,7 +2759,7 @@
             > 0) {
           // This doc's point, in this dimension, is greater than the maximum value of the last cell
           // checked:
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points value "
                   + Arrays.toString(packedValue)
                   + " for field=\""
@@ -2544,7 +2784,7 @@
         int cmp =
             Arrays.compareUnsigned(lastPackedValue, 0, bytesPerDim, packedValue, 0, bytesPerDim);
         if (cmp > 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points value "
                   + Arrays.toString(packedValue)
                   + " for field=\""
@@ -2555,7 +2795,7 @@
                   + Arrays.toString(lastPackedValue));
         } else if (cmp == 0) {
           if (docID < lastDocID) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "packed points value is the same, but docID="
                     + docID
                     + " is out of order vs previous docID="
@@ -2588,7 +2828,7 @@
                 offset,
                 offset + bytesPerDim)
             > 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points cell minPackedValue "
                   + Arrays.toString(minPackedValue)
                   + " is out-of-bounds of the cell's maxPackedValue "
@@ -2609,7 +2849,7 @@
                 offset,
                 offset + bytesPerDim)
             < 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points cell minPackedValue "
                   + Arrays.toString(minPackedValue)
                   + " is out-of-bounds of the global minimum "
@@ -2629,7 +2869,7 @@
                 offset,
                 offset + bytesPerDim)
             < 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points cell maxPackedValue "
                   + Arrays.toString(maxPackedValue)
                   + " is out-of-bounds of the global minimum "
@@ -2649,7 +2889,7 @@
                 offset,
                 offset + bytesPerDim)
             > 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points cell minPackedValue "
                   + Arrays.toString(minPackedValue)
                   + " is out-of-bounds of the global maximum "
@@ -2668,7 +2908,7 @@
                 offset,
                 offset + bytesPerDim)
             > 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "packed points cell maxPackedValue "
                   + Arrays.toString(maxPackedValue)
                   + " is out-of-bounds of the global maximum "
@@ -2688,12 +2928,12 @@
 
     private void checkPackedValue(String desc, byte[] packedValue, int docID) {
       if (packedValue == null) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             desc + " is null for docID=" + docID + " field=\"" + fieldName + "\"");
       }
 
       if (packedValue.length != (docID < 0 ? packedIndexBytesCount : packedBytesCount)) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             desc
                 + " has incorrect length="
                 + packedValue.length
@@ -2763,7 +3003,7 @@
 
       // Validate docCount
       if (status.docCount != reader.numDocs()) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "docCount=" + status.docCount + " but saw " + status.docCount + " undeleted docs");
       }
 
@@ -2797,6 +3037,7 @@
   public static Status.DocValuesStatus testDocValues(
       CodecReader reader, PrintStream infoStream, boolean failFast) throws IOException {
     long startNS = System.nanoTime();
+
     final Status.DocValuesStatus status = new Status.DocValuesStatus();
     try {
       if (infoStream != null) {
@@ -2856,7 +3097,7 @@
       if (i++ % 10 == 1) {
         int doc2 = it2.advance(doc - 1);
         if (doc2 < doc - 1) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field="
                   + field
                   + ": doc="
@@ -2869,7 +3110,7 @@
           doc2 = it2.nextDoc();
         }
         if (doc2 != doc) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field="
                   + field
                   + ": doc="
@@ -2879,7 +3120,7 @@
                   + ")");
         }
         if (it2.docID() != doc) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field="
                   + field
                   + ": doc="
@@ -2905,7 +3146,7 @@
       if (i++ % 13 == 1) {
         boolean found = it2.advanceExact(doc - 1);
         if ((doc - 1 == lastDoc) != found) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field="
                   + field
                   + ": doc="
@@ -2915,7 +3156,7 @@
                   + ")");
         }
         if (it2.docID() != doc - 1) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field="
                   + field
                   + ": doc="
@@ -2927,14 +3168,14 @@
 
         boolean found2 = it2.advanceExact(doc - 1);
         if (found != found2) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv iterator field=" + field + ": doc=" + (doc - 1) + " has unstable advanceExact");
         }
 
         if (i % 2 == 0) {
           int doc2 = it2.nextDoc();
           if (doc != doc2) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "dv iterator field="
                     + field
                     + ": doc="
@@ -2944,7 +3185,7 @@
                     + ")");
           }
           if (it2.docID() != doc) {
-            throw new RuntimeException(
+            throw new CheckIndexException(
                 "dv iterator field="
                     + field
                     + ": doc="
@@ -2963,7 +3204,7 @@
   private static void checkBinaryDocValues(
       String fieldName, int maxDoc, BinaryDocValues bdv, BinaryDocValues bdv2) throws IOException {
     if (bdv.docID() != -1) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "binary dv iterator for field: "
               + fieldName
               + " should start at docID=-1, but got "
@@ -2975,11 +3216,11 @@
       value.isValid();
 
       if (bdv2.advanceExact(doc) == false) {
-        throw new RuntimeException("advanceExact did not find matching doc ID: " + doc);
+        throw new CheckIndexException("advanceExact did not find matching doc ID: " + doc);
       }
       BytesRef value2 = bdv2.binaryValue();
       if (value.equals(value2) == false) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "nextDoc and advanceExact report different values: " + value + " != " + value2);
       }
     }
@@ -2988,7 +3229,7 @@
   private static void checkSortedDocValues(
       String fieldName, int maxDoc, SortedDocValues dv, SortedDocValues dv2) throws IOException {
     if (dv.docID() != -1) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "sorted dv iterator for field: "
               + fieldName
               + " should start at docID=-1, but got "
@@ -3000,25 +3241,25 @@
     for (int doc = dv.nextDoc(); doc != NO_MORE_DOCS; doc = dv.nextDoc()) {
       int ord = dv.ordValue();
       if (ord == -1) {
-        throw new RuntimeException("dv for field: " + fieldName + " has -1 ord");
+        throw new CheckIndexException("dv for field: " + fieldName + " has -1 ord");
       } else if (ord < -1 || ord > maxOrd) {
-        throw new RuntimeException("ord out of bounds: " + ord);
+        throw new CheckIndexException("ord out of bounds: " + ord);
       } else {
         maxOrd2 = Math.max(maxOrd2, ord);
         seenOrds.set(ord);
       }
 
       if (dv2.advanceExact(doc) == false) {
-        throw new RuntimeException("advanceExact did not find matching doc ID: " + doc);
+        throw new CheckIndexException("advanceExact did not find matching doc ID: " + doc);
       }
       int ord2 = dv2.ordValue();
       if (ord != ord2) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "nextDoc and advanceExact report different ords: " + ord + " != " + ord2);
       }
     }
     if (maxOrd != maxOrd2) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv for field: "
               + fieldName
               + " reports wrong maxOrd="
@@ -3027,7 +3268,7 @@
               + maxOrd2);
     }
     if (seenOrds.cardinality() != dv.getValueCount()) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv for field: "
               + fieldName
               + " has holes in its ords, valueCount="
@@ -3041,7 +3282,7 @@
       term.isValid();
       if (lastValue != null) {
         if (term.compareTo(lastValue) <= 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv for field: " + fieldName + " has ords out of order: " + lastValue + " >=" + term);
         }
       }
@@ -3057,7 +3298,7 @@
     long maxOrd2 = -1;
     for (int docID = dv.nextDoc(); docID != NO_MORE_DOCS; docID = dv.nextDoc()) {
       if (dv2.advanceExact(docID) == false) {
-        throw new RuntimeException("advanceExact did not find matching doc ID: " + docID);
+        throw new CheckIndexException("advanceExact did not find matching doc ID: " + docID);
       }
       long lastOrd = -1;
       long ord;
@@ -3065,15 +3306,15 @@
       while ((ord = dv.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {
         long ord2 = dv2.nextOrd();
         if (ord != ord2) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "nextDoc and advanceExact report different ords: " + ord + " != " + ord2);
         }
         if (ord <= lastOrd) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "ords out of order: " + ord + " <= " + lastOrd + " for doc: " + docID);
         }
         if (ord < 0 || ord > maxOrd) {
-          throw new RuntimeException("ord out of bounds: " + ord);
+          throw new CheckIndexException("ord out of bounds: " + ord);
         }
         lastOrd = ord;
         maxOrd2 = Math.max(maxOrd2, ord);
@@ -3081,17 +3322,17 @@
         ordCount++;
       }
       if (ordCount == 0) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "dv for field: " + fieldName + " returned docID=" + docID + " yet has no ordinals");
       }
       long ord2 = dv2.nextOrd();
       if (ord != ord2) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "nextDoc and advanceExact report different ords: " + ord + " != " + ord2);
       }
     }
     if (maxOrd != maxOrd2) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv for field: "
               + fieldName
               + " reports wrong maxOrd="
@@ -3100,7 +3341,7 @@
               + maxOrd2);
     }
     if (seenOrds.cardinality() != dv.getValueCount()) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv for field: "
               + fieldName
               + " has holes in its ords, valueCount="
@@ -3115,7 +3356,7 @@
       assert term.isValid();
       if (lastValue != null) {
         if (term.compareTo(lastValue) <= 0) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "dv for field: " + fieldName + " has ords out of order: " + lastValue + " >=" + term);
         }
       }
@@ -3127,7 +3368,7 @@
       String fieldName, int maxDoc, SortedNumericDocValues ndv, SortedNumericDocValues ndv2)
       throws IOException {
     if (ndv.docID() != -1) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv iterator for field: "
               + fieldName
               + " should start at docID=-1, but got "
@@ -3136,32 +3377,32 @@
     for (int docID = ndv.nextDoc(); docID != NO_MORE_DOCS; docID = ndv.nextDoc()) {
       int count = ndv.docValueCount();
       if (count == 0) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "sorted numeric dv for field: "
                 + fieldName
                 + " returned docValueCount=0 for docID="
                 + docID);
       }
       if (ndv2.advanceExact(docID) == false) {
-        throw new RuntimeException("advanceExact did not find matching doc ID: " + docID);
+        throw new CheckIndexException("advanceExact did not find matching doc ID: " + docID);
       }
       int count2 = ndv2.docValueCount();
       if (count != count2) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "advanceExact reports different value count: " + count + " != " + count2);
       }
       long previous = Long.MIN_VALUE;
       for (int j = 0; j < count; j++) {
         long value = ndv.nextValue();
         if (value < previous) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "values out of order: " + value + " < " + previous + " for doc: " + docID);
         }
         previous = value;
 
         long value2 = ndv2.nextValue();
         if (value != value2) {
-          throw new RuntimeException(
+          throw new CheckIndexException(
               "advanceExact reports different value: " + value + " != " + value2);
         }
       }
@@ -3171,7 +3412,7 @@
   private static void checkNumericDocValues(
       String fieldName, NumericDocValues ndv, NumericDocValues ndv2) throws IOException {
     if (ndv.docID() != -1) {
-      throw new RuntimeException(
+      throw new CheckIndexException(
           "dv iterator for field: "
               + fieldName
               + " should start at docID=-1, but got "
@@ -3182,11 +3423,11 @@
       long value = ndv.longValue();
 
       if (ndv2.advanceExact(doc) == false) {
-        throw new RuntimeException("advanceExact did not find matching doc ID: " + doc);
+        throw new CheckIndexException("advanceExact did not find matching doc ID: " + doc);
       }
       long value2 = ndv2.longValue();
       if (value != value2) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "advanceExact reports different value: " + value + " != " + value2);
       }
     }
@@ -3312,7 +3553,7 @@
               // Make sure FieldInfo thinks this field is vector'd:
               final FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
               if (!fieldInfo.hasVectors()) {
-                throw new RuntimeException(
+                throw new CheckIndexException(
                     "docID="
                         + j
                         + " has term vectors for field="
@@ -3330,7 +3571,7 @@
 
                 Terms postingsTerms = postingsFields.terms(field);
                 if (postingsTerms == null) {
-                  throw new RuntimeException(
+                  throw new CheckIndexException(
                       "vector field=" + field + " does not exist in postings; doc=" + j);
                 }
                 TermsEnum postingsTermsEnum = postingsTerms.iterator();
@@ -3344,7 +3585,7 @@
                   assert postings != null;
 
                   if (!postingsTermsEnum.seekExact(term)) {
-                    throw new RuntimeException(
+                    throw new CheckIndexException(
                         "vector term="
                             + term
                             + " field="
@@ -3359,7 +3600,7 @@
 
                   final int advanceDoc = postingsDocs.advance(j);
                   if (advanceDoc != j) {
-                    throw new RuntimeException(
+                    throw new CheckIndexException(
                         "vector term="
                             + term
                             + " field="
@@ -3374,14 +3615,14 @@
                   final int doc = postings.nextDoc();
 
                   if (doc != 0) {
-                    throw new RuntimeException(
+                    throw new CheckIndexException(
                         "vector for doc " + j + " didn't return docID=0: got docID=" + doc);
                   }
 
                   if (postingsHasFreq) {
                     final int tf = postings.freq();
                     if (postingsHasFreq && postingsDocs.freq() != tf) {
-                      throw new RuntimeException(
+                      throw new CheckIndexException(
                           "vector term="
                               + term
                               + " field="
@@ -3401,7 +3642,7 @@
                         if (postingsTerms.hasPositions()) {
                           int postingsPos = postingsDocs.nextPosition();
                           if (terms.hasPositions() && pos != postingsPos) {
-                            throw new RuntimeException(
+                            throw new CheckIndexException(
                                 "vector term="
                                     + term
                                     + " field="
@@ -3434,7 +3675,7 @@
                           int postingsStartOffset = postingsDocs.startOffset();
                           int postingsEndOffset = postingsDocs.endOffset();
                           if (startOffset != postingsStartOffset) {
-                            throw new RuntimeException(
+                            throw new CheckIndexException(
                                 "vector term="
                                     + term
                                     + " field="
@@ -3447,7 +3688,7 @@
                                     + postingsStartOffset);
                           }
                           if (endOffset != postingsEndOffset) {
-                            throw new RuntimeException(
+                            throw new CheckIndexException(
                                 "vector term="
                                     + term
                                     + " field="
@@ -3473,7 +3714,7 @@
                             // we have payloads, but not at this position.
                             // postings has payloads too, it should not have one at this position
                             if (postingsDocs.getPayload() != null) {
-                              throw new RuntimeException(
+                              throw new CheckIndexException(
                                   "vector term="
                                       + term
                                       + " field="
@@ -3487,7 +3728,7 @@
                             // we have payloads, and one at this position
                             // postings should also have one at this position, with the same bytes.
                             if (postingsDocs.getPayload() == null) {
-                              throw new RuntimeException(
+                              throw new CheckIndexException(
                                   "vector term="
                                       + term
                                       + " field="
@@ -3500,7 +3741,7 @@
                             }
                             BytesRef postingsPayload = postingsDocs.getPayload();
                             if (!payload.equals(postingsPayload)) {
-                              throw new RuntimeException(
+                              throw new CheckIndexException(
                                   "vector term="
                                       + term
                                       + " field="
@@ -3622,6 +3863,7 @@
     boolean doSlowChecks = false;
     boolean verbose = false;
     boolean doChecksumsOnly = false;
+    int threadCount;
     List<String> onlySegments = new ArrayList<>();
     String indexPath = null;
     String dirImpl = null;
@@ -3720,6 +3962,16 @@
         }
         i++;
         opts.dirImpl = args[i];
+      } else if ("-threadCount".equals(arg)) {
+        if (i == args.length - 1) {
+          throw new IllegalArgumentException("-threadCount requires a following number");
+        }
+        i++;
+        opts.threadCount = Integer.parseInt(args[i]);
+        if (opts.threadCount <= 0) {
+          throw new IllegalArgumentException(
+              "-threadCount requires a number larger than 0, but got: " + opts.threadCount);
+        }
       } else {
         if (opts.indexPath != null) {
           throw new IllegalArgumentException("ERROR: unexpected extra argument '" + args[i] + "'");
@@ -3787,8 +4039,14 @@
     setDoSlowChecks(opts.doSlowChecks);
     setChecksumsOnly(opts.doChecksumsOnly);
     setInfoStream(opts.out, opts.verbose);
+    // user provided thread count via command line argument, overriding the default with user
+    // provided value
+    if (opts.threadCount > 0) {
+      setThreadCount(opts.threadCount);
+    }
 
     Status result = checkIndex(opts.onlySegments);
+
     if (result.missingSegments) {
       return 1;
     }
@@ -3825,13 +4083,15 @@
     }
   }
 
-  private static void checkSoftDeletes(
+  private static Status.SoftDeletsStatus checkSoftDeletes(
       String softDeletesField,
       SegmentCommitInfo info,
       SegmentReader reader,
       PrintStream infoStream,
       boolean failFast)
       throws IOException {
+
+    Status.SoftDeletsStatus status = new Status.SoftDeletsStatus();
     if (infoStream != null) infoStream.print("    test: check soft deletes.....");
     try {
       int softDeletes =
@@ -3839,7 +4099,7 @@
               DocValuesFieldExistsQuery.getDocValuesDocIdSetIterator(softDeletesField, reader),
               reader.getLiveDocs());
       if (softDeletes != info.getSoftDelCount()) {
-        throw new RuntimeException(
+        throw new CheckIndexException(
             "actual soft deletes: " + softDeletes + " but expected: " + info.getSoftDelCount());
       }
     } catch (Exception e) {
@@ -3847,13 +4107,41 @@
         throw IOUtils.rethrowAlways(e);
       }
       msg(infoStream, "ERROR [" + String.valueOf(e.getMessage()) + "]");
+      status.error = e;
       if (infoStream != null) {
         e.printStackTrace(infoStream);
       }
     }
+
+    return status;
   }
 
   private static double nsToSec(long ns) {
     return ns / 1000000000.0;
   }
+
+  /**
+   * The marker RuntimeException used by CheckIndex APIs when index integrity failure is detected.
+   */
+  public static class CheckIndexException extends RuntimeException {
+
+    /**
+     * Constructs a new CheckIndexException with the error message
+     *
+     * @param message the detailed error message.
+     */
+    public CheckIndexException(String message) {
+      super(message);
+    }
+
+    /**
+     * Constructs a new CheckIndexException with the error message, and the root cause
+     *
+     * @param message the detailed error message.
+     * @param cause the underlying cause.
+     */
+    public CheckIndexException(String message, Throwable cause) {
+      super(message, cause);
+    }
+  }
 }
